# Installs Hashicorp Serf, technically out of scope for a Goiardi cookbook
# but is provided for convenience when installing Shovey. If you plan to
# use Serf for other things than Goiradi Shovey jobs I recommend installing
# it from a different cookbook.
property :instance_name, String, name_property: true
property :instance_path, String, default: '/usr/sbin'
property :version, String, default: '0.8.2'
property :archive_url, [String, NilClass], default: nil
property :archive_dir, [String, NilClass], default: nil
property :user, String, name_property: true
property :group, String, name_property: true
property :manage_systemd_service, [TrueClass, FalseClass], default: true
property :conf, Hash, default: {}
property :options, [String, NilClass], default: nil

default_action :install

action :install do
  group new_resource.group do
    comment "Generated by #{Chef::Dist::PRODUCT} for #{new_resource.instance_name}"
    append true
    system true
    action :create
  end

  user new_resource.user do
    comment "Generated by #{Chef::Dist::PRODUCT} for #{new_resource.instance_name}"
    gid new_resource.group
    shell '/sbin/nologin'
    home serf_home
    manage_home true
    system true
    action :create
  end

  remote_file "#{archive_directory}/#{new_resource.instance_name}.zip" do
    source new_resource.archive_url || derive_serf_download_url
    owner new_resource.user
    group new_resource.group
    mode '0755'
    notifies :extract, "archive_file[#{archive_directory}/#{new_resource.instance_name}.zip]", :immediately
  end

  archive_file "#{archive_directory}/#{new_resource.instance_name}.zip" do
    destination new_resource.instance_path
    overwrite true
    action :nothing
  end

  file bin_path do
    group new_resource.group
    owner new_resource.user
    mode '0755'
  end

  all_dirs.each do |dir|
    directory dir do
      owner new_resource.user
      group new_resource.group
      mode '0750'
      recursive true
      action :create
    end
  end

  file "#{conf_dir}/#{new_resource.instance_name}.json" do
    owner new_resource.user
    group new_resource.group
    mode '0644'
    content Chef::JSONCompat.to_json_pretty(merged_conf.compact)
    action :create
  end

  if new_resource.manage_systemd_service
    systemd_unit "#{new_resource.instance_name}.service" do
      content <<-EOU.gsub(/^\s+/, '')
      [Unit]
      Description=Hashicorp Serf service orchestrator
      After=network.target

      [Service]
      Type=exec
      PIDFile=/var/lock/#{new_resource.instance_name}.pid
      ExecStart=#{bin_path} agent #{serf_options}
      Restart=On-failure

      [Install]
      WantedBy=multi-user.target
      EOU
      action [:create, :enable, :start]
      subscribes :restart, "file[#{conf_dir}/#{new_resource.instance_name}.json]", :delayed
      subscribes :restart, "remote_file[#{bin_path}]", :delayed
    end
  end
end

action :remove do
  if new_resource.manage_systemd_service
    systemd_unit "#{new_resource.instance_name}.service" do
      action [:stop, :disable, :delete]
    end
  end

  file bin_path do
    action :delete
  end

  all_dirs.each do |dir|
    directory dir do
      recursive true
      action :delete
    end
  end

  user new_resource.user do
    action :remove
  end

  group new_resource.group do
    action :remove
  end
end

action_class do
  require 'chef/dist'
  include Goiardi::Helpers

  def serf_options
    return new_resource.options if new_resource.options
    new_resource.options ? new_resource.options : "-config-file #{conf_dir}/#{new_resource.instance_name}.json"
  end

  def conf_dir
    "/etc/#{new_resource.instance_name}"
  end

  def all_dirs
    dirs = [
      archive_directory,
      conf_dir,
    ]
    %w(queue_save_file whitelist).each do |file|
      dirs.push(::File.dirname(merged_conf[file.to_sym])) if merged_conf[file.to_sym]
    end
    clean_directories(dirs.compact.uniq, new_resource.instance_name)
  end

  def serf_home
    "/home/#{new_resource.user}"
  end

  def archive_directory
    new_resource.archive_dir || serf_home
  end

  def bin_path
    "#{new_resource.instance_path}/#{new_resource.instance_name}"
  end

  def derive_serf_download_url
    "https://releases.hashicorp.com/serf/#{new_resource.version}/#{serf_archive_name(node['os'], system_arch(node['kernel']['machine']), new_resource.version)}"
  end

  def merged_conf
    {
      node_name: node['fqdn'],
      log_level: 'warn',
    }.merge(new_resource.conf.to_h).compact
  end
end
