# This resource installs the goiardi bin and all its' prerequisites
property :instance_name, String, name_property: true
property :instance_path, String, default: '/usr/sbin'
property :version, String, default: 'latest'
property :bin_url, [String, NilClass], default: nil
property :user, String, name_property: true
property :group, String, name_property: true
property :conf, Hash, default: {}
property :private_key_path, [String, NilClass], default: nil
property :manage_conf, [TrueClass, FalseClass], default: true
property :manage_systemd_service, [TrueClass, FalseClass], default: true
property :options, [String, NilClass], default: nil

default_action :install

action :install do
  group new_resource.group do
    comment "Generated by #{Chef::Dist::PRODUCT} for #{new_resource.instance_name}"
    append true
    system true
    action :create
  end

  user new_resource.user do
    comment "Generated by #{Chef::Dist::PRODUCT} for #{new_resource.instance_name}"
    gid new_resource.group
    shell '/sbin/nologin'
    system true
    action :create
  end

  remote_file bin_path do
    # Using node attributes in resources is often considered poor form
    # But these are automatic attributes and I have faith in ohai!
    source new_resource.bin_url || release_by_platform_url('ctdk/goiardi', node['os'], system_arch(node['kernel']['machine']), new_resource.version)
    owner new_resource.user
    group new_resource.group
    mode '0755'
  end

  all_dirs.each do |dir|
    directory dir do
      owner new_resource.user
      group new_resource.group
      mode '0750'
      recursive true
      action :create
    end
  end

  # If the user is providing his own private key, chown it to the correct user
  if merged_conf.has_key?(:'use-shovey')
    if new_resource.private_key_path
      file new_resource.private_key_path do
        user new_resource.user
        group new_resource.group
        mode '0600'
        action :create
      end

    else
      openssl_rsa_private_key "#{conf_dir}/#{new_resource.instance_name}.pem" do
        group new_resource.group
        owner new_resource.user
        sensitive true
      end

      openssl_rsa_public_key "#{conf_dir}/#{new_resource.instance_name}.pub" do
        group new_resource.group
        owner new_resource.user
        private_key_path "#{conf_dir}/#{new_resource.instance_name}.pem"
        sensitive true
      end
    end
  end

  if new_resource.manage_conf
    template "#{conf_dir}/#{new_resource.instance_name}.conf" do
      source 'goiardi.conf.erb'
      cookbook 'goiardi'
      owner new_resource.user
      group new_resource.group
      mode '0644'
      variables(conf: merged_conf.compact)
      action :create
      notifies :restart, "systemd_unit[#{new_resource.instance_name}.service]", :delayed if new_resource.manage_systemd_service
    end
  end

  if new_resource.manage_systemd_service
    systemd_unit "#{new_resource.instance_name}.service" do
      content <<-EOU.gsub(/^\s+/, '')
      [Unit]
      Description=Goiardi, a go implementation of the Chef Server
      After=network.target

      [Service]
      Type=exec
      User=#{new_resource.user}
      PIDFile=/var/lock/#{new_resource.instance_name}.pid
      ExecStart=#{new_resource.instance_path}/#{new_resource.instance_name} #{goiardi_options}
      Restart=On-failure

      [Install]
      WantedBy=multi-user.target
      EOU
      action [:create, :enable, :start]
      subscribes :restart, "remote_file[#{bin_path}]", :delayed
    end
  end
end

action :remove do
  if new_resource.manage_systemd_service
    systemd_unit "#{new_resource.instance_name}.service" do
      action [:stop, :disable, :delete]
    end
  end

  file bin_path do
    action :delete
  end

  all_dirs.each do |dir|
    directory dir do
      recursive true
      action :delete
    end
  end

  user new_resource.user do
    action :remove
  end

  group new_resource.group do
    action :remove
  end
end

action_class do
  require 'chef/dist'
  # Generic helpers, those that do not rely directly on resource properties or ohai data
  include Goiardi::Helpers

  # Resource specific helper methods
  def goiardi_options
    new_resource.options ? new_resource.options : "-c #{merged_conf[:'conf-root']}/#{new_resource.instance_name}.conf"
  end

  def all_dirs
    dirs = [
      merged_conf[:'local-filestore-dir'],
      merged_conf[:'conf-root'],
    ]
    # we're only going to operate on folders that match the instance name
    # to avoid recursively chowning/deleting important directories
    %w(log-file index-file data-file).each do |f|
      dirs.push(::File.dirname(merged_conf[f.to_sym])) if merged_conf[f.to_sym]
    end
    clean_directories(dirs.compact.uniq, new_resource.instance_name)
  end

  def bin_path
    "#{new_resource.instance_path}/#{new_resource.instance_name}"
  end

  def conf_dir
    "/etc/#{new_resource.instance_name}"
  end

  def merged_conf
    base = {
      ipaddress: '0.0.0.0',
      port: 4545,
      'index-file': "/var/lib/#{new_resource.instance_name}/#{new_resource.instance_name}-index.bin",
      'data-file': "/var/lib/#{new_resource.instance_name}/#{new_resource.instance_name}-data.bin",
      'log-file': "/var/log/#{new_resource.instance_name}/#{new_resource.instance_name}.log",
      'local-filestore-dir': "/var/lib/#{new_resource.instance_name}/#{new_resource.instance_name}-lfs",
      'freeze-interval': 120,
      'time-slew': '15m',
      'conf-root': conf_dir,
      'use-auth': true,
      'use-ssl': false,
      syslog: false,
      'log-level': 'warning',
      'disable-webui': false,
      'log-events': true,
      'log-event-keep': 1000,
    }
    base[:'sign-priv-key'] = if new_resource.private_key_path
                              new_resource.private_key_path
                            elsif new_resource.conf.to_h.has_key?('use-shovey')
                              "#{conf_dir}/#{new_resource.instance_name}.pem"
                            else
                              nil
                            end
    # Note the use of to_h, it ensures that if a user passes attributes in directly as `conf`
    # that it will be treated as a plain hash instead of a Chef::ImmutableMash
    base.merge(new_resource.conf.to_h).compact
  end
end
